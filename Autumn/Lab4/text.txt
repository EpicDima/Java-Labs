Unfortunately serialization is still pervasive in the Java ecosystem If you are maintaining a system that is based on Java serialization seriously consider migrating to a cross platform structured data representation even though this may be a time consuming endeavor Realistically you may still find yourself having to write or maintain a serializable class It requires great care to write a serializable class that is correct safe and efficient The remainder of this chapter provides advice on when and how to do this In summary serialization is dangerous and should be avoided If you are designing a system from scratch use a cross platform structured data representation such as JSON or protobuf instead Do not deserialize untrusted data If you must do so use object deserialization filtering but be aware that it is not guaranteed to thwart all attacks Avoid writing serializable classes If you must do so exercise great caution Item Implement Serializable with great caution Allowing a class instances to be serialized can be as simple as adding the words implements Serializable to its declaration Because this is so easy to do there was a common misconception that serialization requires little effort on the part of the programmer The truth is far more complex While the immediate cost to make a class serializable can be negligible the long term costs are often substantial A major cost of implementing Serializable is that it decreases the flexibility to change a class implementation once it has been released When a class implements Serializable its byte stream encoding or serialized form becomes part of its exported API Once you distribute a class widely you are generally required to support the serialized form forever just as you are required to support all other parts of the exported API If you do not make the effort to design a custom serialized form but merely accept the default the serialized form will forever be tied to the class original internal representation In other words if you accept the default serialized form the class private and package private instance fields become part of its exported API and the practice of minimizing access to fields Item loses its effectiveness as a tool for information hiding If you accept the default serialized form and later change a class internal representation an incompatible change in the serialized form will result Clients attempting to serialize an instance using an old version of the class and deserialize it using the new one or vice versa will experience program failures It is possible to change the internal representation while maintaining the original serialized form using ObjectOutputStreamputFields and ObjectInputStreamreadFields but it can be difficult and leaves visible warts in the source code If you opt to make a class serializable you should carefully design a high quality serialized form that you re willing to live with for the long haul Items Doing so will add to the initial cost of development but its worth the effort Even a well designed serialized form places constraints on the evolution of a class an ill designed serialized form can be crippling A simple example of the constraints on evolution imposed by serializability concerns stream unique identifiers more commonly known as serial version UIDs Every serializable class has a unique identification number associated with it If you do not specify this number by declaring a static final long field named serial Version UID the system automatically generates it at runtime by applying a cryptographic hash function SHA to the structure of the class This value is affected by the names of the class the interfaces it implements and most of its members including synthetic members generated by the compiler If you change any of these things for example by adding a convenience method the generated serial version UID changes If you fail to declare a serial version UID compatibility will be broken resulting in an InvalidClassException at runtime A second cost of implementing Serializableis that it increases the likelihood of bugs and security holes Item Normally objects are created with constructors serialization is an extra linguistic mechanism for creating objects Whether you accept the default behavior or override it deserialization is a hidden constructor with all of the same issues as other constructors Because there is no explicit constructor associated with deserialization it is easy to forget that you must ensure that it guarantees all of the invariants established by the constructors and that it does not allow an attacker to gain access to the internals of the object under construction Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access Item A third cost of implementing Serializable is that it increases the testing burden associated with releasing a new version of a class When a serializable class is revised it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases andvice versa The amount of testing required is thus proportional to the product of the number of serializable classes and the number of releases which can be large You must ensure both that the serialization deserialization process succeeds and that it results in a faithful replica of the original object The need for testing is reduced if a custom serialized form is carefully designed whenthe class is first written Items Implementing Serializableis not a decision to be undertaken lightly It is essential if a class is to participate in a framework that relies on Java serialization for object transmission or persistence Also it greatly easesthe use of a class as a component in another class that must implement Serializable There are however many costs associated with implementing Serializable Each time you design a class weigh the costs against the benefits Historically value classes such as BigInteger and Instant implemented Serializable and collection classes did too Classes representing active entities such as thread pools should rarely implement Serializable